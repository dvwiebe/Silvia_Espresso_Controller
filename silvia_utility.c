/*
 * File: silvia_utility.c
 * Author: David Wiebe
 * Description: Functions required for the Silvia PID Controller PIC Program
 * Revision History: Rev 0 - July 31, 2017
 */
#include "silvia_utility.h"
/*******************GLOBAL VARIABLES******************************/
/*initialize global variables to default values*/
uint32_t runTime = 0;

//Default PID parameters
union Two_Bytes pidKp = {.uint16 = 140};
union Two_Bytes pidKi = {.uint16 = 1};
union Two_Bytes pidKd = {.uint16 = 3000};

//PID Input / Output    
double pidSetPoint = 0;
double pidOutput = 0;

//Default Brew Setpoint in degC
union Four_Bytes brewSetPoint = {.d = 95.0};
union Four_Bytes steamSetPoint = {.d = 100.0};
double deltaTemperatureC = 0.0;

//Default Brew Toggle and Time
union Two_Bytes brewTime = {.uint16 = 25000};
uint8_t brewTimeToggle = 0; //default is timed brew not active

//Default Pre-Infusion Settings in milli seconds
union Two_Bytes preInfDelay = {.uint16 = 5000};
union Two_Bytes preInfPump = {.uint16 = 1500};
uint8_t preInfToggle = 0; //default is no pre-Infusion

//Default RTDOffset is zero
union Four_Bytes rtdOffset = {.d = 0.0};

//Default timeout setting and menu options    
union Four_Bytes timeOut = {.lInt = 3600000}; //default is 1hr or 60 mins    

//Interrupt Flags
volatile uint8_t steamFlag = 1; //set as one to initialize setpoint on startup screen
volatile uint8_t rtdFlag = 0;
volatile uint8_t brewFlag = 0;
volatile uint8_t brewFirstPassFlag = 1;
volatile uint8_t btnFlag = 0;
volatile uint8_t encFlag = 0;
volatile uint8_t waterFlag = 0;
volatile uint8_t btnActiveFlag = 0;


//Setting Menu Index Counter
int menuIndex = 0;
char *settingNames[] = {"Brew Set Point", "Steam Set Point", "Brew Tmr Toggle",
    "Brew Timer", "PreInf Toggle", "PreInf On Timer", "PreInf Delay", "RTD Offset",
    "Auto Off Timer", "PID - Kp", "PID - Ki", "PID - Kd"};

void delayms(uint16_t delay) {
    uint32_t now = runTime; //capture current runTime

    //while loop ties up program for "delay" for the amount specified in 
    //delay variable
    while ((now + delay) > runTime);
}

void EEPROM_Write(uint8_t *dPointer, uint8_t dAddress, uint8_t bytesToWrite) {
    bytesToWrite++; //increase by one to include data address

    //Local Variables
    uint8_t writeBuffer[bytesToWrite];
    uint8_t slaveTimeOut = 0;
    I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;

    writeBuffer[0] = dAddress;

    //build write buffer
    for (uint8_t i = 1; i <= bytesToWrite; i++) {
        writeBuffer[i] = *dPointer; //assign value at pointer address to buffer
        dPointer++; //increase pointer address        
    }

    I2C1_MasterWrite(writeBuffer, bytesToWrite, EEPROM_ADDRESS, &status);

    while (status == I2C1_MESSAGE_PENDING || status == I2C1_DATA_NO_ACK) {
        if (slaveTimeOut < EEPROM_TIMEOUT)
            slaveTimeOut++;
        else {
            glcd_blank();
            draw_text("EEPROM Write Timed Out", 2, 2, Tahoma7, 1, 1);
            glcd_refresh();
            delayms(10000); //Delay for 10s to allow message to be read
            Sleep_Mode();
        }
        
        //if no ACK received on address write, EEPROM is busy writing previous data; 
        //continue to poll until it's available or timeout is reached
        if(status == I2C1_DATA_NO_ACK)
            I2C1_MasterWrite(writeBuffer, bytesToWrite, EEPROM_ADDRESS, &status);

    }
    
    if (status != I2C1_MESSAGE_COMPLETE) {
        glcd_blank();
        draw_text("EEPROM Write Failed", 2, 2, Tahoma7, 1, 1);
        glcd_refresh();
        delayms(10000); //Delay for 10s to allow message to be read
        Sleep_Mode();
    }

}

void EEPROM_Read(uint8_t *dPointer, uint8_t dAddress, uint8_t bytesToRead) {
    //Local Variables        
    uint8_t slaveTimeOut = 0;
    I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;

    //Write to EEPROM to set address for random read
    I2C1_MasterWrite(&dAddress, 1, EEPROM_ADDRESS, &status);

    while (status == I2C1_MESSAGE_PENDING || status == I2C1_DATA_NO_ACK) {
        if (slaveTimeOut < EEPROM_TIMEOUT)
            slaveTimeOut++;
        else {
            glcd_blank();
            draw_text("EEPROM Write Timed Out", 2, 2, Tahoma7, 1, 1);
            glcd_refresh();
            delayms(10000); //Delay for 10s to allow message to be read
            Sleep_Mode();
        }
        
        //if no ACK received on address write, EEPROM is busy writing previous data; 
        //continue to poll until it's available or timeout is reached
        if(status == I2C1_DATA_NO_ACK)
            I2C1_MasterWrite(&dAddress, 1, EEPROM_ADDRESS, &status);

    }

    //Upon exiting While loop, check if the status shows a fail
    //if not, reset status variables for following read activity
    if (status != I2C1_MESSAGE_COMPLETE) {
        glcd_blank();
        draw_text("EEPROM Write Failed", 2, 2, Tahoma7, 1, 1);
        glcd_refresh();
        delayms(10000); //Delay for 10s to allow message to be read
        Sleep_Mode();
    } else {
        //reset variables
        slaveTimeOut = 0;
        status = I2C1_MESSAGE_PENDING;
    }

    I2C1_MasterRead(dPointer, bytesToRead, EEPROM_ADDRESS, &status);

    while (status == I2C1_MESSAGE_PENDING) {
        if (slaveTimeOut < EEPROM_TIMEOUT)
            slaveTimeOut++;
        else {
            glcd_blank();
            draw_text("EEPROM Read Timed Out", 2, 2, Tahoma7, 1, 1);
            glcd_refresh();
            delayms(10000); //Delay for 10s to allow message to be read
            Sleep_Mode();
        }

    }

    if (status != I2C1_MESSAGE_COMPLETE) {
        glcd_blank();
        draw_text("EEPROM Read Failed", 2, 2, Tahoma7, 1, 1);
        glcd_refresh();
        delayms(10000); //Delay for 10s to allow message to be read
        Sleep_Mode();
    }

}

void Read_User_Settings() {
    uint8_t eepromFlags[12] = {0}; //temp variable to read flags from EEPROM    

    //read flags; these flags tell whether or not user settings exist for each parameter
    EEPROM_Read(eepromFlags, 0, 12);

    uint8_t i;

    for (i = 0; i < 12; i++) {
        if (eepromFlags[i] == 1) {
            switch (i) {
                case 0:
                    EEPROM_Read(pidKp.uint8, 12, 2);
                    break;
                case 1:
                    EEPROM_Read(pidKi.uint8, 14, 2);
                    break;
                case 2:
                    EEPROM_Read(pidKd.uint8, 16, 2);
                    break;
                case 3:
                    EEPROM_Read(brewSetPoint.uint8, 18, 4);
                    break;
                case 4:
                    EEPROM_Read(preInfPump.uint8, 22, 2);
                    break;
                case 5:
                    EEPROM_Read(steamSetPoint.uint8, 24, 4);
                    break;
                case 6:
                    EEPROM_Read(brewTime.uint8, 28, 2);
                    break;
                case 7:
                    EEPROM_Read(preInfDelay.uint8, 30, 2);
                    break;
                case 8:
                    EEPROM_Read(rtdOffset.uint8, 32, 4);
                    break;
                case 9:
                    EEPROM_Read(timeOut.uint8, 36, 4);
                    break;
                case 10:
                    preInfToggle = 1;
                    break;
                case 11:
                    brewTimeToggle = 1;
                    break;
            }
        }
    }
    

}

void Sleep_Mode() {
    //power down ADS1220 (RTD circuit)    
    ADS1220Command(ADS1220_PWRDWN);

    //power down LCD
    glcd_command(GLCD_CMD_DISPLAY_OFF);
    LCDLED_SetLow(); //turns off backlight

    //instruct pic to enter sleep mode
    Sleep();

    //following code is executed upon leaving sleep mode
    //sleep mode is exited upon a user triggered interrupt    

    runTime = 0; //resets run time

    //restart ADS1220 readings; no need to resend registry values    
    ADS1220Command(ADS1220_START);

    //power up LCD
    glcd_command(GLCD_CMD_DISPLAY_ON);
    LCDLED_SetHigh();

}

void LCD_Draw_Borders() {
    glcd_blank(); //clear LCD screen

    //Draw Borders and Titles for LCD Initialization 
    draw_filled_rectangle(1, 1, 25, 22, 1); // Left Title Block     
    draw_filled_rectangle(1, 24, 88, 35, 1); //Setpoint Title Block
    draw_filled_rectangle(1, 36, 1, 46, 1); //Border
    draw_filled_rectangle(1, 47, 88, 47, 1); //Border
    draw_filled_rectangle(89, 48, 89, 64, 1); //Border
    draw_rectangle(89, 1, 128, 36, 1); //READY Border
    draw_filled_rectangle(89, 37, 128, 47, 1); //Timer Block    
    draw_filled_rectangle(1, 48, 4, 64, 1); //Scroll Bar    
    draw_filled_rectangle(1, 50, 4, 50, 0); //Scroll Indicator

    draw_text("Boiler", 2, 1, Tahoma7, 1, 0);
    draw_text("Temp", 2, 12, Tahoma7, 1, 0);
    draw_text("Timer (s)", 90, 36, Tahoma7, 1, 0);
    draw_rectangle(75, 3, 77, 5, 1); //degree Symbol
    draw_text("C", 78, 3, Tahoma12, 1, 1); // 'C' Celsius     
    draw_text("Set Point", 27, 25, Tahoma7, 1, 0);
    draw_rectangle(72, 37, 73, 38, 1); //small degree Symbol
    draw_text("C", 75, 36, Tahoma7, 1, 1); // small 'C' Celsius
    draw_text("User Settings", 10, 51, Tahoma7, 1, 1);

    //update screen
    glcd_refresh();
}

const unsigned char espresso_logo [] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F,
    0x3F, 0x1F, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0xE3, 0x83, 0x03,
    0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F, 0x3F, 0x7F, 0x7F,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x7C, 0xF0, 0xC0, 0x00, 0x00, 0x01, 0x8F, 0xFE,
    0x7C, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xF0,
    0xF0, 0x90, 0x90, 0x90, 0x00, 0x80, 0xC0, 0x40, 0x40, 0x40, 0x00, 0xC0, 0xC0, 0x40, 0x40, 0xC0,
    0x80, 0x00, 0xC0, 0xC0, 0x80, 0xC0, 0x00, 0x80, 0xC0, 0x40, 0x40, 0xC0, 0x80, 0x00, 0x80, 0xC0,
    0x40, 0x40, 0x40, 0x00, 0x80, 0xC0, 0x40, 0x40, 0x40, 0x00, 0x10, 0xF0, 0xF0, 0x10, 0x00, 0x00,
    0x00, 0x80, 0x60, 0x18, 0x00, 0xE0, 0xF0, 0x10, 0x10, 0x10, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x7F, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xEC, 0xE7, 0xE3, 0xE0, 0xE0, 0xE0, 0xE1, 0xE0,
    0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xEC, 0xE7, 0xE3, 0xE0, 0xC0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1F, 0xFF, 0xFF, 0xFF, 0x00, 0x0F,
    0x0F, 0x08, 0x08, 0x08, 0x00, 0x09, 0x0B, 0x0B, 0x0F, 0x06, 0x00, 0x3F, 0x3F, 0x08, 0x08, 0x0F,
    0x07, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x0D, 0x09, 0x09, 0x09, 0x00, 0x09, 0x0B,
    0x0B, 0x0F, 0x06, 0x00, 0x09, 0x0B, 0x0B, 0x0F, 0x06, 0x00, 0x08, 0x0F, 0x0F, 0x08, 0x00, 0x30,
    0x0C, 0x03, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x08, 0x08, 0x08, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD,
    0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x78, 0x38,
    0x38, 0x1C, 0x3C, 0x38, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x1C, 0xF8, 0xC0, 0xC0, 0xF8, 0x1C, 0x00, 0x00, 0x08, 0xFC, 0xFC, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF8, 0xFC, 0x04, 0x04, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0xF0,
    0xF0, 0x78, 0x3C, 0x1E, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x02, 0x00,
    0x00, 0x03, 0x03, 0x00, 0x01, 0x03, 0x02, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFE, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x1F, 0x3F, 0x3F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
    0x7F, 0x7F, 0x7F, 0x7F, 0x3F, 0x3F, 0x1F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x03, 0x03, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xF8, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x0C, 0xF0, 0x80, 0xF0, 0x1C, 0x70, 0x80, 0xF0, 0x0C, 0x00, 0xF4, 0x00, 0xE0, 0x50, 0x50,
    0x60, 0x00, 0xFC, 0x24, 0x24, 0x24, 0xD8, 0x00, 0xE0, 0x50, 0x50, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0xC0, 0x40, 0x41, 0x40, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01,
    0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x40, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFC,
    0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF8, 0xF8, 0xFC, 0xFC, 0xFE,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x1F, 0x12, 0x12, 0x12, 0x0D, 0x00, 0x1F, 0x00, 0x01, 0x00, 0x0E, 0x15, 0x15, 0x16, 0x00,
    0x07, 0x18, 0x0C, 0x07, 0x0C, 0x18, 0x07, 0x00, 0x1F, 0x00, 0x1F, 0x01, 0x01, 0x01, 0x1E, 0x00,
    0x0E, 0x51, 0x51, 0x51, 0x3F, 0x00, 0x00, 0x18, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x00, 0x0E, 0x11,
    0x11, 0x11, 0x0E, 0x00, 0x1F, 0x01, 0x01, 0x1E, 0x01, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00
};
